Optimization Ideas

Segment Tree for Range Queries:
Use a segment tree to compute the maximum deliciousness efficiently.
Precompute the maximum pairwise deliciousness for non-restricted ranges.


Dynamic Programming:
Use dynamic programming to compute the best possible cuts for each restricted range

SAMPLE TEST:

INPUT:

5

3 5 2 1 4

1 1 1 1 1

2

1 3

2 2

OUTPUT:

6

8


Program :

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

// Function to calculate the edge sum between two vertices in a circular graph
int get_edge_sum(int u, int v, const vector<int>& prefix_sum, int total_length) {
    if (u <= v) {
        return prefix_sum[v] - prefix_sum[u];
    } else {
        return total_length - (prefix_sum[u] - prefix_sum[v]);
    }
}

vector<int> maximum_deliciousness(int n, const vector<int>& A, const vector<int>& B, const vector<pair<int, int>>& queries) {
    // Precompute prefix sums for edges
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        prefix_sum[i] = prefix_sum[i - 1] + B[i - 1];
    }
    int total_length = prefix_sum[n];

    // Result array
    vector<int> results;

    // Process each query
    for (const auto& query : queries) {
        int l = query.first, r = query.second;

        // Determine restricted vertices using modular arithmetic
        vector<bool> restricted(n + 1, false);
        if (l <= r) {
            for (int i = l; i <= r; ++i) restricted[i] = true;
        } else {
            for (int i = r; i <= n; ++i) restricted[i] = true;
            for (int i = 1; i <= l; ++i) restricted[i] = true;
        }

        // Use two-pointer approach to find maximum deliciousness
        int max_deliciousness = 0;
        int curr_sum = 0, start = 0;

        for (int i = 1; i <= n; ++i) {
            if (restricted[i]) continue; // Skip restricted vertices
            for (int j = i; j <= n; ++j) {
                if (restricted[j]) break; // Skip restricted vertices
                int edge_sum = get_edge_sum(i, start++];
            }
        }
